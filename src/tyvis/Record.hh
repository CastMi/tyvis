#ifndef RECORD_HH
#define RECORD_HH

// Copyright (c) Ohio Board of Regents and the University of Cincinnati.  
// All Rights Reserved.

// UC MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY OF THE
// SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
// OR NON-INFRINGEMENT.  UC SHALL NOT BE LIABLE FOR ANY DAMAGES SUFFERED BY
// LICENSEE AS A RESULT OF USING, RESULT OF USING, MODIFYING OR
// DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.

// By using or copying this Software, Licensee agrees to abide by the
// intellectual property laws, and all other applicable laws of the U.S.,
// and the terms of this license.

// You may modify, distribute, and use the software contained in this
// package under the terms of the "GNU LIBRARY GENERAL PUBLIC LICENSE"
// version 2, June 1991. A copy of this license agreement can be found in
// the file "LGPL", distributed with this archive.

#include "tyvis/tyvis-config.h"
#include "tyvis/CompositeLiteral.hh"
#include "tyvis/RecordTypeInfo.hh"
#include <vector>
using std::vector;

class ObjectBase;
class Element;
class SubElementFactory;

/** The class Record.

    This class represents all the record types and record subtype that get used
    in a VHDL simulation.  THe primary functionality of this class is to act as
    a place holder for the elements contained by an record type.  The basic
    structure for the record type is provided by the RecordTypeInfo class that
    contains all the necessary type information for each field of the Record
    object (signal/variable).
*/
    
class Record : public CompositeLiteral {
public:
  //@{
  /** Constructors */
  Record();
  explicit Record( const RecordTypeInfo &typeInfo );
  explicit Record( const SubElementFactory &factory );
  /** 
      Constructor.  Calls to this one get generated by record-valued
      aggregates.
  */
  Record( const RecordTypeInfo &typeInfo,
	  TyvisVarArgs &initValue );

  /**
     Constructor used in subprogram argument temporaries.
  */
  Record( const TypeInfo &typeInfo,
	  const RValue &initValue );

  /** 
      Copy Constructor
  */
  Record( const Record &that );
  //@}

  /** The destructor for Record.  */
  virtual ~Record();

 /** Returns a clone of the object.  All the fields/elements are duplicated.
      The return value is a fresh/new duplicate and the caller must ensure that
      the return value is deleted (otherwise, memory will leak)

      @return A pointer to the clone of the object.
 */
  RValue *clone() const;


  /** Assignment operator for record types.  NOTE that this is more of an
      internal method.  It should NOT be used to assign values for variables and
      signals.  The updateVal method should be used for that purpose.

      @param source The source Record object.
      @return The Record object with new value (*this)
  */  
  RValue &operator=(const RValue &source );
 
  /** Assignment operator for record types.

      @param source The source Record object.
      @return The Record object with new value (*this)
  */ 
  Record &operator=(const Record &source);

  const string &getDataType() const;
  static const string &getRecordDataType();
  void serialize( SerializedInstance * ) const;

  string toString() const;
  void print( ostream &os ) const;

protected:
  
private:
};

#endif
